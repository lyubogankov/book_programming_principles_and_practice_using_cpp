## Notes

## Chapter Review Questions

<!-- Note - use the GitHub-supported chart-syntax mermaid-js (?) for the grammar chart! -->

 1. What do we mean by “Programming is understanding”?

2. The chapter details the creation of a calculator program. Write a short analysis of what the calculator should be able to do.

3. How do you break a problem up into smaller manageable parts?

4. Why is creating a small, limited version of a program a good idea?

5. Why is feature creep a bad idea?

6. What are the three main phases of software development?

7. What is a “use case”?

8. What is the purpose of testing?

9. According to the outline in the chapter, describe the difference between a `Term`, an `Expression`, a `Number`, and a `Primary`.

10. In the chapter, an input was broken down into its component `Terms`, `Expressions`, `Primarys`, and `Numbers`. Do this for (17+4)/(5–1).

11. Why does the program not have a function called `number()`?

12. What is a token?

13. What is a grammar? A grammar rule?

14. What is a class? What do we use classes for?

15. How can we provide a default value for a member of a class?

16. In the expression function, why is the default for the switch-statement to “put back” the token?

17. What is “look-ahead”?

18. What does `putback()` do and why is it useful?

19. Why is the remainder (modulus) operation, %, difficult to implement in the term()?

20. What do we use the two data members of the `Token` class for?

21. Why do we (sometimes) split a class’s members into private and public members?

22. What happens in the `Token_stream` class when there is a token in the buffer and the `get() function` is called?

23. Why were the ';' and 'q' characters added to the switch-statement in the get() function of the Token_stream class?

24. When should we start testing our program?

25. What is a “user-defined type”? Why would we want one?

26. What is the interface to a C++ “user-defined type”?

27. Why do we want to rely on libraries of code?